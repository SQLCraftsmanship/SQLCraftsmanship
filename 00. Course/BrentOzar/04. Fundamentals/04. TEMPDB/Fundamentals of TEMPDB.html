<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>Brent Ozar Course Notes</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only],
.vscode-high-contrast:not(.vscode-high-contrast-light) img[src$=\#gh-light-mode-only],
.vscode-high-contrast-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
    <script type="module">
      import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
      mermaid.initialize({ startOnLoad: true });
    </script>
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <h1 id="brent-ozar-course-notes">Brent Ozar Course Notes</h1>
<style>
r { color: red }
o { color: Orange }
g { color: Green }
lg { color: lightgreen }
b { color: Blue }
lb { color: lightblue }
</style>
<ul>
<li>
<p>Initial Training Page</p>
<p><a href="https://training.brentozar.com/courses/">https://training.brentozar.com/courses/</a></p>
</li>
</ul>
<hr>
<h2 id="1-first-responder-kit">1. First Responder Kit</h2>
<ul>
<li>Index
<ul>
<li><a href="#What-are-going-to-cover">What are going to cover</a></li>
<li><a href="#How-the-Version-Store-Affects-TempDB">How the Version Store Affects TempDB</a></li>
<li><a href="#NonCluster-Index">NonCluster Index</a></li>
<li><a href="#Key-lookups">Key lookups</a></li>
<li><a href="#The-tipping-point">The tipping point</a></li>
<li><a href="#How-the-engine-chooses-between-plans">How the engine chooses between plans</a></li>
<li><a href="#Cost-based-query-optimization">Cost-based query optimization</a></li>
<li><a href="#How-statistics-come-into-play">How statistics come into play</a></li>
<li><a href="#How-your-query-syntax-affects-all-this">How your query syntax affects all this</a></li>
<li><a href="#How-included-columns-mitigate-these-problems">How included columns mitigate these problems</a></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>What are going to cover
<ol>
<li>What uses the TEMPDB?</li>
<li>How that affects performance and configuration?</li>
<li>Where to host the TEMPDB? based on your workload?</li>
<li>How to monitor it?</li>
</ol>
</li>
</ul>
<ol>
<li>What uses the TEMPDB?</li>
</ol>
<ul>
<li>How the Version Store Affects TempDB</li>
</ul>
<p>We’re going to start the class by talking about things that use TempDB. First up are a pair of my favorite features: Read Committed Snapshot Isolation (RCSI) and Snapshot Isolation (SI) help you quickly mitigate blocking problems. Readers don’t block writers, and writers don’t block readers. It’s also known as optimistic concurrency or multi-version concurrency control (MVCC).</p>
<p>SQL Server performs this magic trick by storing multiple versions of the same row in something called the version store. The version store lives in TempDB (although SQL 2019 lets you put it in the user database itself, which introduces other problems)</p>
<p>In this session, I’ll demonstrate how the version store helps queries, and the impact it has on TempDB.</p>
<pre><code class="language-sql"><span class="hljs-comment">-- To avoid issue if you run the entire script at once.</span>
RAISERROR(N<span class="hljs-string">&#x27;Oops! No, don&#x27;&#x27;t just hit F5. Run these demos one at a time.&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-number">1</span>) <span class="hljs-keyword">WITH</span> LOG;
GO

<span class="hljs-comment">-- Check that the RCSI is OFF</span>
USE StackOverflow2013;
GO
<span class="hljs-keyword">ALTER</span> DATABASE <span class="hljs-keyword">CURRENT</span> 
  <span class="hljs-keyword">SET</span> READ_COMMITTED_SNAPSHOT OFF <span class="hljs-keyword">WITH</span> NO_WAIT
GO

<span class="hljs-comment">/* We have to execute this on one SSMS conn whitout run the ROLLBACK */</span>
<span class="hljs-comment">/* Query windows 1 */</span>
<span class="hljs-keyword">BEGIN</span> TRAN
  <span class="hljs-keyword">UPDATE</span> dbo.Users
  <span class="hljs-keyword">SET</span> Location <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Iceland&#x27;</span>
  <span class="hljs-keyword">WHERE</span> DisplayName <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Brent Ozar&#x27;</span>;

<span class="hljs-comment">/* While that is open, run this in another window: */</span>
<span class="hljs-comment">/* Query windows 2 */</span>
<span class="hljs-keyword">SELECT</span> Location
  <span class="hljs-keyword">FROM</span> dbo.Users
  <span class="hljs-keyword">WHERE</span> DisplayName <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Brent Ozar&#x27;</span>;

<span class="hljs-comment">/* If we stop the execution on Query Windows 2 and re-run using NOLOCK, which worked: */</span>
<span class="hljs-keyword">SELECT</span> Location
  <span class="hljs-keyword">FROM</span> dbo.Users <span class="hljs-keyword">WITH</span> (NOLOCK)
  <span class="hljs-keyword">WHERE</span> DisplayName <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Brent Ozar&#x27;</span>;

<span class="hljs-comment">/* But with NOLOCK:
  1. You can see rows twice.
  2. You can skip rows
  3. Your query can fail with an error
  4. You can see data that was never committed, like what&#x27;s about to happen here: We can see the 
    Iceland as a result when the update to Iceland was never COMMITED.
*/</span>
</code></pre>
<p>Fortunately, there's a better way: RCSI or SI, aka optimistic concurrency, aka MVCC.
<a href="https://BrentOzar.com/go/rcsi">https://BrentOzar.com/go/rcsi</a></p>
<p>You turn it on at the database level, but you have to be the only active connection:</p>
<pre><code class="language-sql"><span class="hljs-keyword">ALTER</span> DATABASE <span class="hljs-keyword">CURRENT</span> 
  <span class="hljs-keyword">SET</span> READ_COMMITTED_SNAPSHOT <span class="hljs-keyword">ON</span> <span class="hljs-keyword">WITH</span> NO_WAIT
GO

<span class="hljs-comment">/* We execute the same query again */</span>
<span class="hljs-keyword">BEGIN</span> TRAN
  <span class="hljs-keyword">UPDATE</span> dbo.Users
  <span class="hljs-keyword">SET</span> Location <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Iceland&#x27;</span>
  <span class="hljs-keyword">WHERE</span> DisplayName <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Brent Ozar&#x27;</span>;

<span class="hljs-comment">/* We run the same SELECT again */</span>
<span class="hljs-keyword">SELECT</span> Location
<span class="hljs-keyword">FROM</span> dbo.Users
<span class="hljs-keyword">WHERE</span> DisplayName <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Brent Ozar&#x27;</span>;  
</code></pre>
<p>Without NOLOCK, and without indexing or changing the query at all, it works! It sees a version of truth that's true before the
update transaction finishes.</p>
<p>Writers no longer block readers, and readers no longer block writers either.</p>
<p>The magic happens because SQL Server stores versions of rows during transactions. They live in the &quot;version store&quot;, which lives in
TempDB (until SQL 2019, which lets you move the version store into the database - but that's outside of the scope of this class.)</p>
<p>You can query to see how much space is used by the version store.</p>
<pre><code class="language-sql"><span class="hljs-comment">/* SQL Server 2016 SP2 &amp; newer: */</span>
<span class="hljs-comment">/* Per DB*/</span>
<span class="hljs-keyword">SELECT</span> DB_NAME(database_id) <span class="hljs-keyword">AS</span> database_name,
  reserved_space_kb <span class="hljs-operator">/</span> <span class="hljs-number">1024.0</span> <span class="hljs-keyword">AS</span> version_store_mb
<span class="hljs-keyword">FROM</span> sys.dm_tran_version_store_space_usage
<span class="hljs-keyword">WHERE</span> reserved_space_kb <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span>
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-number">2</span> <span class="hljs-keyword">DESC</span>;

<span class="hljs-comment">/* Previous versions of SQL don&#x27;t break it out per database: */</span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUM</span> (version_store_reserved_page_count)<span class="hljs-operator">*</span><span class="hljs-number">8</span><span class="hljs-operator">/</span><span class="hljs-number">1024.0</span>  <span class="hljs-keyword">as</span> version_store_mb
<span class="hljs-keyword">FROM</span> tempdb.sys.dm_db_file_space_usage;
</code></pre>
<p><img src="file:///c:\Perso\GitHub\LiberatoriLucas\Course\BrentOzar\04. Fundamentals\04. TEMPDB\Images\VersionStoreQuery.png" alt="alt text"></p>
<pre><code class="language-sql"><span class="hljs-comment">/* The bigger your transactions are, the bigger the version store becomes.
   Our transaction is still open - and let&#x27;s &quot;modify&quot; more data. */</span>
<span class="hljs-keyword">UPDATE</span> dbo.Users
    <span class="hljs-keyword">SET</span> Reputation <span class="hljs-operator">=</span> Reputation;
GO
</code></pre>
<p><img src="file:///c:\Perso\GitHub\LiberatoriLucas\Course\BrentOzar\04. Fundamentals\04. TEMPDB\Images\VersionStoreIncreasing.png" alt="alt text"></p>
<pre><code class="language-sql"><span class="hljs-comment">/* Inserts don&#x27;t affect the size as long as we don&#x27;t need to log prior versions of rows: */</span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>
  <span class="hljs-keyword">INTO</span> dbo.Badges_New
  <span class="hljs-keyword">FROM</span> dbo.Badges;
GO
</code></pre>
<p>This happens because we don't need a copy of something that didn't exist before. We can't have a copy of a data that it wasn't INSERTED.</p>
<pre><code class="language-sql"><span class="hljs-comment">/* But deletes will: */</span>
<span class="hljs-keyword">DELETE</span> dbo.Badges;
GO
</code></pre>
<pre><code class="language-sql"><span class="hljs-comment">/* Commit our changes, and check the version store size: */</span>
<span class="hljs-keyword">COMMIT</span>;
</code></pre>
<p>The space is not realize automatically after the COMMIT. The SQL do it when he can on the background.</p>
<pre><code class="language-sql"><span class="hljs-comment">/* RCSI &amp; SI aren&#x27;t the only things that use the version store, either. Triggers use it too! */</span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> upd_Users_Waiter <span class="hljs-keyword">ON</span> dbo.Users <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">AS</span>
<span class="hljs-keyword">BEGIN</span>
    WAITFOR DELAY <span class="hljs-string">&#x27;00:00:30&#x27;</span>;
<span class="hljs-keyword">END</span>
GO

<span class="hljs-keyword">UPDATE</span> dbo.Users <span class="hljs-keyword">SET</span> Reputation <span class="hljs-operator">=</span> Reputation;
GO
<span class="hljs-comment">/* And while it runs, check the version store in another window: */</span>
</code></pre>
<p><img src="file:///c:\Perso\GitHub\LiberatoriLucas\Course\BrentOzar\04. Fundamentals\04. TEMPDB\Images\VersionStoreSizeWithATrigger.png" alt="alt text"></p>
<p>Why? Because triggers have virtual tables called INSERTED and DELETED:
<a href="https://docs.microsoft.com/en-us/sql/relational-databases/triggers/use-the-inserted-and-deleted-tables?view=sql-server-ver15">https://docs.microsoft.com/en-us/sql/relational-databases/triggers/use-the-inserted-and-deleted-tables?view=sql-server-ver15</a></p>
<p>Those have copies of the rows before &amp; after your change! Big updates = big version store. (Inserts &amp; deletes are only 1x the size.)</p>
<p>What you learned in this session:</p>
<ul>
<li>Read Committed Snapshot Isolation (RCSI) and Snapshot Isolation (SI) reduce blocking by storing versions of rows in TempDB.</li>
<li>Update &amp; delete transactions basically copy their changes into TempDB.</li>
<li>The more data a transaction changes,and the longer the transaction stays open, and the more queries need to read those versions,
the bigger &amp; slower TempDB is going to get.</li>
<li>Triggers don't reduce blocking - but they do have virtual INSERTED &amp; DELETED tables, and those use the version store too.</li>
<li>Cleanup may not happen quickly enough for you, especially when any one database is holding transactions open: other databases'
versions can't be cleaned up.</li>
<li>There's no simple formula to calculate how big your TempDB will get, or how long transactions will stay open. It depends on your app
code. General speaking the size of the TEMPDB can be the 25% of the total dbs sizing. This is a good starting point.</li>
<li>This is why 3rd party monitoring tools warn about TempDB growths and large version store sizes. If someone leaves a transaction open,
locks their workstation, and goes home, you're doomed.</li>
</ul>
<p>Learning resources:</p>
<p>Open transactions in any database mean the version store can't be cleaned out:
<a href="https://kohera.be/blog/sql-server/tempdb-the-ghost-of-version-store/">https://kohera.be/blog/sql-server/tempdb-the-ghost-of-version-store/</a>
<a href="https://docs.microsoft.com/en-us/archive/blogs/sqlserverstorageengine/managing-tempdb-in-sql-server-tempdb-basics-version-store-growth-and-removing-stale-row-versions">https://docs.microsoft.com/en-us/archive/blogs/sqlserverstorageengine/managing-tempdb-in-sql-server-tempdb-basics-version-store-growth-and-removing-stale-row-versions</a></p>
<p>Implicit transactions often cause problems with this:
<a href="https://www.brentozar.com/archive/2018/02/set-implicit_transactions-one-hell-bad-idea/">https://www.brentozar.com/archive/2018/02/set-implicit_transactions-one-hell-bad-idea/</a>
<a href="https://www.brentozar.com/archive/2019/07/using-implicit-transactions-you-really-need-rcsi/">https://www.brentozar.com/archive/2019/07/using-implicit-transactions-you-really-need-rcsi/</a>
<a href="https://thesurfingdba.weebly.com/my-version-store-is-huge.html">https://thesurfingdba.weebly.com/my-version-store-is-huge.html</a></p>
<pre><code class="language-sql"><span class="hljs-comment">/* Query to check your own servers to find out which databases need the version store: */</span>
<span class="hljs-keyword">SELECT</span> 
    db.name
  , db.is_read_committed_snapshot_on <span class="hljs-keyword">AS</span> rcsi_on
  , db.snapshot_isolation_state_desc <span class="hljs-keyword">AS</span> snapshot_isolation
  , <span class="hljs-built_in">COALESCE</span>(vs.reserved_space_kb, <span class="hljs-number">0</span>) <span class="hljs-operator">/</span> <span class="hljs-number">1024.0</span> <span class="hljs-keyword">AS</span> version_store_mb
<span class="hljs-keyword">FROM</span> sys.databases db
<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> sys.dm_tran_version_store_space_usage vs 
<span class="hljs-keyword">ON</span> db.database_id <span class="hljs-operator">=</span> vs.database_id
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> vs.reserved_space_kb <span class="hljs-keyword">DESC</span>, db.name;
</code></pre>
<ol start="2">
<li>How that affects performance and configuration?</li>
</ol>
<ul>
<li>How Temp Tables Are Different from Regular Tables
It seems so simple at first: queries create temp tables, load data, and drop ’em. How hard can it be?</li>
</ul>
<p>Spectacularly tricky, as it turns out.</p>
<p>Temp tables share some behaviors with real tables, but they also have their own tricky behavior when it comes to statistics and execution plans. We’ll start by creating a real table to recap how statistics work, and then try the same task with a temp table to see what optimization tricks SQL Server has up its sleeve.</p>
<pre><code class="language-sql"><span class="hljs-comment">/* Let&#x27;s create a real table: */</span>
USE tempdb;
GO

<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> dbo.Users_temp;
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> dbo.Users_temp 
  (Id <span class="hljs-type">INT</span>,
  DisplayName NVARCHAR(<span class="hljs-number">40</span>),
  Location NVARCHAR(<span class="hljs-number">100</span>));

<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> dbo.Users_temp(Id, DisplayName, Location)
  <span class="hljs-keyword">SELECT</span> Id, DisplayName, Location
  <span class="hljs-keyword">FROM</span> StackOverflow2013.dbo.Users;
GO

<span class="hljs-comment">/* When you run a query that would benefit from having statistics on a column, like this, when SQL Server needs to guess the memory required for the sort: */</span>
<span class="hljs-keyword">SELECT</span> TOP <span class="hljs-number">1000</span> <span class="hljs-operator">*</span>
  <span class="hljs-keyword">FROM</span> dbo.Users_temp
  <span class="hljs-keyword">WHERE</span> DisplayName <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Abhishek&#x27;</span>
  <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> Location;
GO

<span class="hljs-comment">-- After the execution the SQL create an automatic statistics</span>
sp_BlitzIndex <span class="hljs-variable">@TableName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Users_temp&#x27;</span>;

<span class="hljs-comment">/* Now let&#x27;s try the same thing with a temp table: */</span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> #Users_temp 
  (Id <span class="hljs-type">INT</span>,
   DisplayName NVARCHAR(<span class="hljs-number">40</span>),
   Location NVARCHAR(<span class="hljs-number">100</span>));

<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> #Users_temp(Id, DisplayName, Location)
  <span class="hljs-keyword">SELECT</span> Id, DisplayName, Location
  <span class="hljs-keyword">FROM</span> StackOverflow2013.dbo.Users;

<span class="hljs-keyword">SELECT</span> TOP <span class="hljs-number">1000</span> <span class="hljs-operator">*</span>
<span class="hljs-keyword">FROM</span> #Users_temp
<span class="hljs-keyword">WHERE</span> DisplayName <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Abhishek&#x27;</span>
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> Location;
GO

<span class="hljs-comment">/* The same statistics process needs to happen, but it&#x27;s a little harder to see since temp tables don&#x27;t show up in Object Explorer: */</span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> sys.all_objects <span class="hljs-keyword">WHERE</span> name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;#Users_temp%&#x27;</span>

sp_BlitzIndex 
  <span class="hljs-variable">@TableName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;#Users_temp_________________________________________________________________________________________________________000000000024&#x27;</span>;
GO

<span class="hljs-comment">/* Things to discuss:
  * Temp Table
    * The table has stats just like a real table
    * The table has an actual size just like a real table

  * Temp tables are kinda like real tables, except for:
    * They get special names behind the scenes
    * They&#x27;re only accessible per-session: one session shouldn&#x27;t be able to read someone else&#x27;s data

  * But temp tables also get some optimizations that aren&#x27;t immediately obvious when you&#x27;re creating just one table at a time.
    Let&#x27;s create a stored procedure that will do some dumb work: */</span>

<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> #Users_temp;
GO

USE StackOverflow2013
GO

<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">ALTER</span> PROC dbo.usp_GetUsers <span class="hljs-variable">@Location</span> NVARCHAR(<span class="hljs-number">100</span>), <span class="hljs-variable">@DisplayName</span> NVARCHAR(<span class="hljs-number">40</span>) <span class="hljs-keyword">AS</span>
<span class="hljs-keyword">BEGIN</span>
  <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> #Users(
    Id          <span class="hljs-type">INT</span>,
    DisplayName NVARCHAR(<span class="hljs-number">40</span>),
    Location    NVARCHAR(<span class="hljs-number">100</span>) );

  <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> #Users(Id, DisplayName, Location)
    <span class="hljs-keyword">SELECT</span> Id, DisplayName, Location
    <span class="hljs-keyword">FROM</span>   dbo.Users
    <span class="hljs-keyword">WHERE</span>  Location <span class="hljs-operator">=</span> <span class="hljs-variable">@Location</span>;

  <span class="hljs-keyword">SELECT</span> TOP <span class="hljs-number">1000</span> <span class="hljs-operator">*</span>
  <span class="hljs-keyword">FROM</span>  #Users
  <span class="hljs-keyword">WHERE</span> DisplayName <span class="hljs-operator">=</span> <span class="hljs-variable">@DisplayName</span>
  <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> Location;

  <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> #Users;
<span class="hljs-keyword">END</span>
GO

<span class="hljs-comment">/* Turn on actual plans: */</span>
<span class="hljs-keyword">EXEC</span> usp_GetUsers <span class="hljs-variable">@Location</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;India&#x27;</span>, <span class="hljs-variable">@DisplayName</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Abhishek&#x27;</span>
</code></pre>
<p><img src="file:///c:\Perso\GitHub\LiberatoriLucas\Course\BrentOzar\04. Fundamentals\04. TEMPDB\Images\ExecutionPlanForIndia.png" alt="alt text"></p>
<pre><code class="language-sql"><span class="hljs-comment">/* How did your estimates vs actuals look?
  Here&#x27;s what happened:
    1. SQL Server created a temp table
    2. We loaded it
    3. When the SELECT ran, SQL Server realized it needed statistics on the temp table, so it read the temp table and created the stats.
    4. SQL Server read the temp table for the SELECT

  Now, run this, but BEFORE you run it, think about which of the above 4 steps SQL Server will do: */</span>
<span class="hljs-keyword">EXEC</span> usp_GetUsers <span class="hljs-variable">@Location</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Russia&#x27;</span>, <span class="hljs-variable">@DisplayName</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Aleksey&#x27;</span>
GO
</code></pre>
<p><img src="file:///c:\Perso\GitHub\LiberatoriLucas\Course\BrentOzar\04. Fundamentals\04. TEMPDB\Images\ExecutionPlanForRusia.png" alt="alt text"></p>
<pre><code class="language-sql"><span class="hljs-comment">/* How did your estimates vs actuals look?
  Guess which TWO steps SQL Server didn&#x27;t actually do:
    1. SQL Server created a temp table
    2. We loaded it
    3. When the SELECT ran, SQL Server realized it needed statistics on the temp table, so it read the temp table and created the stats
    4. SQL Server read the temp table for the SELECT

  Let&#x27;s prove it by adding a DBCC SHOW_STATISTICS in the proc to show the contents of the stats:
*/</span>

<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">ALTER</span> PROC dbo.usp_GetUsers <span class="hljs-variable">@Location</span> NVARCHAR(<span class="hljs-number">100</span>), <span class="hljs-variable">@DisplayName</span> NVARCHAR(<span class="hljs-number">40</span>) <span class="hljs-keyword">AS</span>
<span class="hljs-keyword">BEGIN</span>
  <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> #Users
    (Id <span class="hljs-type">INT</span>,
    DisplayName NVARCHAR(<span class="hljs-number">40</span>),
    Location NVARCHAR(<span class="hljs-number">100</span>));

  <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> #Users(Id, DisplayName, Location)
    <span class="hljs-keyword">SELECT</span> Id, DisplayName, Location
    <span class="hljs-keyword">FROM</span> dbo.Users
    <span class="hljs-keyword">WHERE</span> Location <span class="hljs-keyword">LIKE</span> <span class="hljs-variable">@Location</span>;

  <span class="hljs-keyword">SELECT</span> TOP <span class="hljs-number">1000</span> <span class="hljs-operator">*</span>
    <span class="hljs-keyword">FROM</span> #Users
    <span class="hljs-keyword">WHERE</span> DisplayName <span class="hljs-operator">=</span> <span class="hljs-variable">@DisplayName</span>
    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> Location;

  <span class="hljs-comment">/* THIS IS NEW: */</span>
  DBCC SHOW_STATISTICS(<span class="hljs-string">&#x27;tempdb..#Users&#x27;</span>, DisplayName)

  <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> #Users;
<span class="hljs-keyword">END</span>
GO

<span class="hljs-comment">/* Try one: */</span>
<span class="hljs-keyword">EXEC</span> usp_GetUsers <span class="hljs-variable">@Location</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;India&#x27;</span>, <span class="hljs-variable">@DisplayName</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Abhishek&#x27;</span>

<span class="hljs-comment">-- Note</span>
<span class="hljs-comment">-- When you execute the SP using India the stats shows Indian names</span>

<span class="hljs-comment">/* Then run it for another: */</span>
<span class="hljs-keyword">EXEC</span> usp_GetUsers <span class="hljs-variable">@Location</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Russia&#x27;</span>, <span class="hljs-variable">@DisplayName</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Aleksey&#x27;</span>

<span class="hljs-comment">-- Note</span>
<span class="hljs-comment">-- When you execute the SP using India the stats shows Indian names too. ERROR!!</span>

<span class="hljs-comment">/* Try freeing the plan cache: */</span>
DBCC FREEPROCCACHE;
GO

<span class="hljs-comment">/* Now try Russia first: */</span>
<span class="hljs-keyword">EXEC</span> usp_GetUsers <span class="hljs-variable">@Location</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Russia&#x27;</span>, <span class="hljs-variable">@DisplayName</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Aleksey&#x27;</span>
<span class="hljs-comment">-- Note</span>
<span class="hljs-comment">-- When you execute the SP using India the stats shows Rusain names</span>

<span class="hljs-comment">/* Then India: */</span>
<span class="hljs-keyword">EXEC</span> usp_GetUsers <span class="hljs-variable">@Location</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;India&#x27;</span>, <span class="hljs-variable">@DisplayName</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Abhishek&#x27;</span>

<span class="hljs-comment">/* 
THIS IS TWO DIFFERENT ISSUES:
  1. Parameter sniffing, but also
  2. THE TEMP TABLE&#x27;S STATS ARE NOT CHANGING!
  
  WE ARE ACTUALLY SEEING SOMEONE ELSE&#x27;S STATS. 
*/</span>

<span class="hljs-comment">/* 
 Here&#x27;s what&#x27;s happening:
  1. SQL Server created a temp table - WE&#x27;RE NOT DOING THIS!
  2. We loaded it
  3. When the SELECT ran, SQL Server realized it needed statistics on the temp table, so it read the temp table and created the stats -
     WE&#x27;RE NOT DOING THIS EITHER!
  4. SQL Server read the temp table for the select

  Temp tables have a tricky optimization:
    Their structure and their statistics can be reused across different sessions. This is part of the magic that helps temp tables run
    faster.

    However, depending on what you DO to the temp tables, you can change that behavior. Temp tables get cached if they&#x27;re created with a
    single CREATE, and then not changed afterwards.
    
    For example, here I&#x27;ve added an index to the temp table, and now each time I run it, I get unique stats just for that temp table: 
*/</span>

<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">ALTER</span> PROC dbo.usp_GetUsers <span class="hljs-variable">@Location</span> NVARCHAR(<span class="hljs-number">100</span>), <span class="hljs-variable">@DisplayName</span> NVARCHAR(<span class="hljs-number">40</span>) <span class="hljs-keyword">AS</span>
<span class="hljs-keyword">BEGIN</span>
  <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> #Users
    (Id <span class="hljs-type">INT</span>,
    DisplayName NVARCHAR(<span class="hljs-number">40</span>),
    Location NVARCHAR(<span class="hljs-number">100</span>));

  <span class="hljs-comment">/* THIS IS NEW */</span>
  <span class="hljs-keyword">CREATE</span> INDEX Id <span class="hljs-keyword">ON</span> #Users(Id);

  <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> #Users(Id, DisplayName, Location)
    <span class="hljs-keyword">SELECT</span> Id, DisplayName, Location
    <span class="hljs-keyword">FROM</span> dbo.Users
    <span class="hljs-keyword">WHERE</span> Location <span class="hljs-keyword">LIKE</span> <span class="hljs-variable">@Location</span>;

  <span class="hljs-keyword">SELECT</span> TOP <span class="hljs-number">1000</span> <span class="hljs-operator">*</span>
    <span class="hljs-keyword">FROM</span> #Users
    <span class="hljs-keyword">WHERE</span> DisplayName <span class="hljs-operator">=</span> <span class="hljs-variable">@DisplayName</span>
    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> Location;

  DBCC SHOW_STATISTICS(<span class="hljs-string">&#x27;tempdb..#Users&#x27;</span>, DisplayName)

  <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> #Users;
<span class="hljs-keyword">END</span>
GO

<span class="hljs-comment">/* Try one: */</span>
<span class="hljs-keyword">EXEC</span> usp_GetUsers <span class="hljs-variable">@Location</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;India&#x27;</span>, <span class="hljs-variable">@DisplayName</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Abhishek&#x27;</span>

<span class="hljs-comment">/* Then run it for another: */</span>
<span class="hljs-keyword">EXEC</span> usp_GetUsers <span class="hljs-variable">@Location</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Russia&#x27;</span>, <span class="hljs-variable">@DisplayName</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Aleksey&#x27;</span>


<span class="hljs-comment">/* This might seem like a good thing: you might think you WANT to get fresh statistics every time your query runs. However, there&#x27;s a dark side: each time you get fresh numbers, you&#x27;re also forcing SQL Server to build new statistics and recompile the execution plan.

You can see this happening by running Erik&#x27;s sp_HumanEvents in another window:
*/</span>
<span class="hljs-keyword">EXEC</span> dbo.sp_HumanEvents <span class="hljs-variable">@event</span>_type <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;recompilations&#x27;</span>, <span class="hljs-variable">@seconds</span>_sample <span class="hljs-operator">=</span> <span class="hljs-number">10</span>
GO

<span class="hljs-comment">/* While you run a few of these: */</span>
<span class="hljs-keyword">EXEC</span> usp_GetUsers <span class="hljs-variable">@Location</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;India&#x27;</span>, <span class="hljs-variable">@DisplayName</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Abhishek&#x27;</span>
<span class="hljs-keyword">EXEC</span> usp_GetUsers <span class="hljs-variable">@Location</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Russia&#x27;</span>, <span class="hljs-variable">@DisplayName</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Aleksey&#x27;</span>
<span class="hljs-keyword">EXEC</span> usp_GetUsers <span class="hljs-variable">@Location</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;India&#x27;</span>, <span class="hljs-variable">@DisplayName</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Abhishek&#x27;</span>
<span class="hljs-keyword">EXEC</span> usp_GetUsers <span class="hljs-variable">@Location</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Russia&#x27;</span>, <span class="hljs-variable">@DisplayName</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Aleksey&#x27;</span>
<span class="hljs-keyword">EXEC</span> usp_GetUsers <span class="hljs-variable">@Location</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;India&#x27;</span>, <span class="hljs-variable">@DisplayName</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Abhishek&#x27;</span>
<span class="hljs-keyword">EXEC</span> usp_GetUsers <span class="hljs-variable">@Location</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Russia&#x27;</span>, <span class="hljs-variable">@DisplayName</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Aleksey&#x27;</span>
GO

<span class="hljs-comment">/* Whereas if we go back to the earlier version of the stored proc that doesn&#x27;t create an index: */</span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">ALTER</span> PROC dbo.usp_GetUsers <span class="hljs-variable">@Location</span> NVARCHAR(<span class="hljs-number">100</span>), <span class="hljs-variable">@DisplayName</span> NVARCHAR(<span class="hljs-number">40</span>) <span class="hljs-keyword">AS</span>
<span class="hljs-keyword">BEGIN</span>
  <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> #Users
    (Id <span class="hljs-type">INT</span>,
    DisplayName NVARCHAR(<span class="hljs-number">40</span>),
    Location NVARCHAR(<span class="hljs-number">100</span>));

  <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> #Users(Id, DisplayName, Location)
    <span class="hljs-keyword">SELECT</span> Id, DisplayName, Location
    <span class="hljs-keyword">FROM</span> dbo.Users
    <span class="hljs-keyword">WHERE</span> Location <span class="hljs-keyword">LIKE</span> <span class="hljs-variable">@Location</span>;

  <span class="hljs-keyword">SELECT</span> TOP <span class="hljs-number">1000</span> <span class="hljs-operator">*</span>
    <span class="hljs-keyword">FROM</span> #Users
    <span class="hljs-keyword">WHERE</span> DisplayName <span class="hljs-operator">=</span> <span class="hljs-variable">@DisplayName</span>
    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> Location;

  <span class="hljs-comment">/* THIS IS NEW: */</span>
  DBCC SHOW_STATISTICS(<span class="hljs-string">&#x27;tempdb..#Users&#x27;</span>, DisplayName)

  <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> #Users;
<span class="hljs-keyword">END</span>
GO

<span class="hljs-comment">/* Then these don&#x27;t get recompiles: */</span>
<span class="hljs-keyword">EXEC</span> usp_GetUsers <span class="hljs-variable">@Location</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;India&#x27;</span>, <span class="hljs-variable">@DisplayName</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Abhishek&#x27;</span>
<span class="hljs-keyword">EXEC</span> usp_GetUsers <span class="hljs-variable">@Location</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Russia&#x27;</span>, <span class="hljs-variable">@DisplayName</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Aleksey&#x27;</span>
<span class="hljs-keyword">EXEC</span> usp_GetUsers <span class="hljs-variable">@Location</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;India&#x27;</span>, <span class="hljs-variable">@DisplayName</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Abhishek&#x27;</span>
<span class="hljs-keyword">EXEC</span> usp_GetUsers <span class="hljs-variable">@Location</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Russia&#x27;</span>, <span class="hljs-variable">@DisplayName</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Aleksey&#x27;</span>
<span class="hljs-keyword">EXEC</span> usp_GetUsers <span class="hljs-variable">@Location</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;India&#x27;</span>, <span class="hljs-variable">@DisplayName</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Abhishek&#x27;</span>
<span class="hljs-keyword">EXEC</span> usp_GetUsers <span class="hljs-variable">@Location</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Russia&#x27;</span>, <span class="hljs-variable">@DisplayName</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Aleksey&#x27;</span>
GO
</code></pre>
<ul>
<li>What you learned in this session:</li>
</ul>
<ol>
<li>
<p>Temp tables have 2 cool optimizations that help	queries run faster, especially when we have a lot of queries that keep creating/dropping temp tables:</p>
<ol>
<li>Their structure can be reused across sessions</li>
<li>Their statistics can be reused, too</li>
</ol>
</li>
<li>
<p>Even if you explicitly drop a temp table, you still get these optimizations.</p>
</li>
<li>
<p>However, if you modify a temp table after it's created, you lose these optimizations, but you GAIN more accurate statistics (at the
expense of slower temp table creation, stats updates, and higher CPU for recompilations.)</p>
</li>
<li>
<p>It's up to you to figure out which one you want:</p>
<ol>
<li>Temp table reuse, or</li>
<li>New temp tables each time</li>
</ol>
</li>
</ol>
<p>There are a lot more code behaviors that influence whether you get temp table &amp; statistics reuse:
<a href="https://www.brentozar.com/archive/2020/11/paul-white-explains-temp-table-caching-3-ways/">https://www.brentozar.com/archive/2020/11/paul-white-explains-temp-table-caching-3-ways/</a></p>
<ol start="3">
<li>How Table Variables Can Be Better Than Temp Tables</li>
</ol>
<p>Table variables have a bad reputation because they don’t have statistics. When you go to pull data out of a table variable, SQL Server can’t accurately predict how many rows will come out, and this causes cascading problems in execution plans.</p>
<p>But sometimes, that’s actually a good thing.</p>
<p>If your SQL Server’s biggest performance problem is high CPU caused by frequent recompilations due to changing statistics on temp tables, and as long as you can deal with the strange estimates on table variables, table variables can actually be the solution to the high CPU problem.</p>
<pre><code class="language-sql"><span class="hljs-comment">/* In the last session, we created a temp table and saw how SQL Server automatically created statistics on it to help build 
better plans.

Let&#x27;s try the same thing with a table variable, starting in SQL Server 2017 compat mode. (You can use 2016 compat mode if 
you&#x27;re running the class on a 2016 VM. Also, turn on actual plans. */</span>
USE StackOverflow2013;
GO
<span class="hljs-keyword">ALTER</span> DATABASE <span class="hljs-keyword">CURRENT</span> <span class="hljs-keyword">SET</span> COMPATIBILITY_LEVEL <span class="hljs-operator">=</span> <span class="hljs-number">140</span>;
GO

<span class="hljs-comment">-- Create variabl table</span>
<span class="hljs-keyword">DECLARE</span> <span class="hljs-variable">@Users</span>_temp <span class="hljs-keyword">TABLE</span>
  (Id <span class="hljs-type">INT</span>,
  DisplayName NVARCHAR(<span class="hljs-number">40</span>),
  Location NVARCHAR(<span class="hljs-number">100</span>));

<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-variable">@Users</span>_temp(Id, DisplayName, Location)
  <span class="hljs-keyword">SELECT</span> Id, DisplayName, Location
  <span class="hljs-keyword">FROM</span> StackOverflow2013.dbo.Users;

<span class="hljs-keyword">SELECT</span> TOP <span class="hljs-number">1000</span> <span class="hljs-operator">*</span>
  <span class="hljs-keyword">FROM</span> <span class="hljs-variable">@Users</span>_temp
  <span class="hljs-keyword">WHERE</span> DisplayName <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Abhishek&#x27;</span>
  <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> Location;

<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> sys.all_objects <span class="hljs-keyword">WHERE</span> name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%Users_temp%&#x27;</span>
GO

<span class="hljs-comment">/* Things to discuss:

* The estimates on the select from the table variable are wrong. Estimated only 1 but the Actual Read is 2.4 million.
* SQL Server doesn&#x27;t know how many rows are in it.
* SQL Server sure as heck doesn&#x27;t know how many	rows will match a specific value either!
* The table variable doesn&#x27;t show up in sys.all_objects
* It&#x27;s not really a table: it behaves more like a variable (those don&#x27;t go in all_objects either)

At first, this sounds bad, because the estimates are wrong.

However...what if the estimates AREN&#x27;T wrong? What if we&#x27;re not searching for Abhishek?
*/</span>

<span class="hljs-keyword">DECLARE</span> <span class="hljs-variable">@Users</span>_temp <span class="hljs-keyword">TABLE</span>
  (Id <span class="hljs-type">INT</span>,
  DisplayName NVARCHAR(<span class="hljs-number">40</span>),
  Location NVARCHAR(<span class="hljs-number">100</span>));

<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-variable">@Users</span>_temp(Id, DisplayName, Location)
  <span class="hljs-keyword">SELECT</span> Id, DisplayName, Location
  <span class="hljs-keyword">FROM</span> StackOverflow2013.dbo.Users;

<span class="hljs-keyword">SELECT</span> TOP <span class="hljs-number">1000</span> <span class="hljs-operator">*</span>
  <span class="hljs-keyword">FROM</span> <span class="hljs-variable">@Users</span>_temp
  <span class="hljs-keyword">WHERE</span> DisplayName <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Brent Ozar&#x27;</span>
  <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> Location;
GO

<span class="hljs-comment">/* If the number of rows we&#x27;re getting out of the table variable don&#x27;t really matter because:

* They&#x27;re low (like under 100), or
* We&#x27;re not doing anything with the rows after we get them, like we&#x27;re not sorting them or joining them to any other objects

Then table variables have a cool advantage:
  * They don&#x27;t have stats
  * But that also means they don&#x27;t trigger recompiles

Use the same stored proc we had last time: */</span>

<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">ALTER</span> PROC dbo.usp_GetUsers_TableVariable
  <span class="hljs-variable">@Location</span> NVARCHAR(<span class="hljs-number">100</span>), <span class="hljs-variable">@DisplayName</span> NVARCHAR(<span class="hljs-number">40</span>) <span class="hljs-keyword">AS</span>
<span class="hljs-keyword">BEGIN</span>
  <span class="hljs-keyword">DECLARE</span> <span class="hljs-variable">@Users</span> <span class="hljs-keyword">TABLE</span>
    (Id <span class="hljs-type">INT</span>,
    DisplayName NVARCHAR(<span class="hljs-number">40</span>),
    Location NVARCHAR(<span class="hljs-number">100</span>));

  <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-variable">@Users</span>(Id, DisplayName, Location)
    <span class="hljs-keyword">SELECT</span> Id, DisplayName, Location
    <span class="hljs-keyword">FROM</span> dbo.Users
    <span class="hljs-keyword">WHERE</span> Location <span class="hljs-operator">=</span> <span class="hljs-variable">@Location</span>;

  <span class="hljs-keyword">SELECT</span> TOP <span class="hljs-number">1000</span> <span class="hljs-operator">*</span>
    <span class="hljs-keyword">FROM</span> <span class="hljs-variable">@Users</span>
    <span class="hljs-keyword">WHERE</span> DisplayName <span class="hljs-operator">=</span> <span class="hljs-variable">@DisplayName</span>
    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> Location;
<span class="hljs-keyword">END</span>
GO

<span class="hljs-comment">/* Run this with actual plan on and note that the estimates are just 1 row: */</span>
<span class="hljs-keyword">EXEC</span> usp_GetUsers_TableVariable <span class="hljs-variable">@Location</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;India&#x27;</span>, <span class="hljs-variable">@DisplayName</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Abhishek&#x27;</span>

<span class="hljs-comment">/* Why 1 row?
  * SQL Server doesn&#x27;t know how many total rows are in the table variable, AND
  * SQL Server doesn&#x27;t know the data distribution either, like the breakdown per name
*/</span>

<span class="hljs-comment">/* Then while we measure recompiles in another window: */</span>
<span class="hljs-keyword">EXEC</span> dbo.sp_HumanEvents <span class="hljs-variable">@event</span>_type <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;recompilations&#x27;</span>, <span class="hljs-variable">@seconds</span>_sample <span class="hljs-operator">=</span> <span class="hljs-number">10</span>
GO

<span class="hljs-comment">/* Run these: */</span>
<span class="hljs-keyword">EXEC</span> usp_GetUsers_TableVariable <span class="hljs-variable">@Location</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;India&#x27;</span>, <span class="hljs-variable">@DisplayName</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Abhishek&#x27;</span>
<span class="hljs-keyword">EXEC</span> usp_GetUsers_TableVariable <span class="hljs-variable">@Location</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Russia&#x27;</span>, <span class="hljs-variable">@DisplayName</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Aleksey&#x27;</span>
<span class="hljs-keyword">EXEC</span> usp_GetUsers_TableVariable <span class="hljs-variable">@Location</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;India&#x27;</span>, <span class="hljs-variable">@DisplayName</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Abhishek&#x27;</span>
<span class="hljs-keyword">EXEC</span> usp_GetUsers_TableVariable <span class="hljs-variable">@Location</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Russia&#x27;</span>, <span class="hljs-variable">@DisplayName</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Aleksey&#x27;</span>
<span class="hljs-keyword">EXEC</span> usp_GetUsers_TableVariable <span class="hljs-variable">@Location</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;India&#x27;</span>, <span class="hljs-variable">@DisplayName</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Abhishek&#x27;</span>
<span class="hljs-keyword">EXEC</span> usp_GetUsers_TableVariable <span class="hljs-variable">@Location</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Russia&#x27;</span>, <span class="hljs-variable">@DisplayName</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Aleksey&#x27;</span>
GO


<span class="hljs-comment">/* So to recap table variables so far:

  * They don&#x27;t get statistics, so:
    * Bad  news: estimates are usually off, but
    * Good news: they don&#x27;t recompile as contents change

Something changed in SQL Server 2019, though: */</span>

<span class="hljs-keyword">ALTER</span> DATABASE <span class="hljs-keyword">CURRENT</span> <span class="hljs-keyword">SET</span> COMPATIBILITY_LEVEL <span class="hljs-operator">=</span> <span class="hljs-number">150</span>; <span class="hljs-comment">/* 2019 */</span>
GO

<span class="hljs-comment">/* Run this with actual plan on: */</span>
<span class="hljs-keyword">EXEC</span> usp_GetUsers_TableVariable <span class="hljs-variable">@Location</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;India&#x27;</span>, <span class="hljs-variable">@DisplayName</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Abhishek&#x27;</span>

<span class="hljs-comment">/* Before, we had an estimate of 1 row because:
  * SQL Server didn&#x27;t know how many total rows are in the table variable, AND
  * SQL Server didn&#x27;t know the data distribution either, like the breakdown per name

But now, hover your mouse over the table variable scan and look at Estimated Number of Rows to be Read.

In SQL Server 2019:
  * SQL Server DOES know how many rows are in it, but
  * Still doesn&#x27;t know the data distribution per name

In some ways, this is an improvement, but in other ways, it&#x27;s a drawback, because watch what happens if you run it for a 
DIFFERENT value:
*/</span>

<span class="hljs-keyword">EXEC</span> usp_GetUsers_TableVariable <span class="hljs-variable">@Location</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Russia&#x27;</span>, <span class="hljs-variable">@DisplayName</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Aleksey&#x27;</span>

<span class="hljs-comment">/* Look at the table variable scan estimates:

* The estimated number of rows TO BE READ is the same
* The estimated number of rows TO BE FOUND is the same

This is NOT THE SAME THING that happens with temp tables. THIS IS DIFFERENT.

With temp table stats reuse:
  * You could inherit someone else&#x27;s table stats
  * You could inherit their estimates, too
  * Those estimates could change as the temp table&#x27;s contents changed as queries run

With table variables:
  * You WILL inherit the total number of rows in the object from the compiled plan
  * There are no column stats (data distribution) to inherit, so these are just consistently wrong
  * This has less to do with temp tables, and more like conventional parameter sniffing problems
*/</span>


<span class="hljs-comment">/****************************************************************************************************************************
What you learned in this session:

Table variables are okay if:

  * Your query brings back a few rows, and
  * The contents (data distribution) of those rows don&#x27;t matter at all, and
  * You&#x27;re not doing anything with the data (like you&#x27;re not sorting it or joining it to other tables)
  * You need to prevent recompilations
  * You don&#x27;t care if you inherit someone else&#x27;s plan (because all the data is tiny anyway no matter what parameters people 
  use)

But be aware that:

  * Even though they don&#x27;t show up in all_objects, they still take up space in TempDB.
  * Starting in SQL Server 2019, the first params for a proc will cause the plan to be built with an understanding of the 
    number of rows in the table variable (but not an understanding of the data distribution, because there are no stats)
****************************************************************************************************************************/</span>
</code></pre>
<ul>
<li>Temp Tables &amp; Table Variables at Scale: PFS/GAM/SGAM Contention</li>
</ul>
<p>Because it’s so easy to create &amp; use temp tables, some applications grow to depend on ’em. If your workload creates, loads, and drops thousands of temp tables per second, you can hit a SQL Server bottleneck involving how SQL Server tracks where objects live in TempDB. It’s called latch contention, also known as PFS/GAM/SGAM contention. We’ll demo it, and then talk about a few ways to resolve it.</p>
<pre><code class="language-sql"><span class="hljs-comment">/* In the last session, we created a temp table and saw how SQL Server automatically created statistics on it to help build 
better plans.

Let&#x27;s try the same thing with a table variable, starting in SQL Server 2017 compat mode. (You can use 2016 compat mode if 
you&#x27;re running the class on a 2016 VM. Also, turn on actual plans. */</span>
USE StackOverflow2013;
GO
<span class="hljs-keyword">ALTER</span> DATABASE <span class="hljs-keyword">CURRENT</span> <span class="hljs-keyword">SET</span> COMPATIBILITY_LEVEL <span class="hljs-operator">=</span> <span class="hljs-number">140</span>;
GO

<span class="hljs-comment">-- Create variabl table</span>
<span class="hljs-keyword">DECLARE</span> <span class="hljs-variable">@Users</span>_temp <span class="hljs-keyword">TABLE</span>
  (Id <span class="hljs-type">INT</span>,
  DisplayName NVARCHAR(<span class="hljs-number">40</span>),
  Location NVARCHAR(<span class="hljs-number">100</span>));

<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-variable">@Users</span>_temp(Id, DisplayName, Location)
  <span class="hljs-keyword">SELECT</span> Id, DisplayName, Location
  <span class="hljs-keyword">FROM</span> StackOverflow2013.dbo.Users;

<span class="hljs-keyword">SELECT</span> TOP <span class="hljs-number">1000</span> <span class="hljs-operator">*</span>
  <span class="hljs-keyword">FROM</span> <span class="hljs-variable">@Users</span>_temp
  <span class="hljs-keyword">WHERE</span> DisplayName <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Abhishek&#x27;</span>
  <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> Location;

<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> sys.all_objects <span class="hljs-keyword">WHERE</span> name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%Users_temp%&#x27;</span>
GO

<span class="hljs-comment">/* Things to discuss:

* The estimates on the select from the table variable are wrong. Estimated only 1 but the Actual Read is 2.4 million.
* SQL Server doesn&#x27;t know how many rows are in it.
* SQL Server sure as heck doesn&#x27;t know how many	rows will match a specific value either!
* The table variable doesn&#x27;t show up in sys.all_objects
* It&#x27;s not really a table: it behaves more like a variable (those don&#x27;t go in all_objects either)

At first, this sounds bad, because the estimates are wrong.

However...what if the estimates AREN&#x27;T wrong? What if we&#x27;re not searching for Abhishek?
*/</span>

<span class="hljs-keyword">DECLARE</span> <span class="hljs-variable">@Users</span>_temp <span class="hljs-keyword">TABLE</span>
  (Id <span class="hljs-type">INT</span>,
  DisplayName NVARCHAR(<span class="hljs-number">40</span>),
  Location NVARCHAR(<span class="hljs-number">100</span>));

<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-variable">@Users</span>_temp(Id, DisplayName, Location)
  <span class="hljs-keyword">SELECT</span> Id, DisplayName, Location
  <span class="hljs-keyword">FROM</span> StackOverflow2013.dbo.Users;

<span class="hljs-keyword">SELECT</span> TOP <span class="hljs-number">1000</span> <span class="hljs-operator">*</span>
  <span class="hljs-keyword">FROM</span> <span class="hljs-variable">@Users</span>_temp
  <span class="hljs-keyword">WHERE</span> DisplayName <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Brent Ozar&#x27;</span>
  <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> Location;
GO

<span class="hljs-comment">/* If the number of rows we&#x27;re getting out of the table variable don&#x27;t really matter because:

* They&#x27;re low (like under 100), or
* We&#x27;re not doing anything with the rows after we get them, like we&#x27;re not sorting them or joining them to any other objects

Then table variables have a cool advantage:
  * They don&#x27;t have stats
  * But that also means they don&#x27;t trigger recompiles

Use the same stored proc we had last time: */</span>

<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">ALTER</span> PROC dbo.usp_GetUsers_TableVariable
  <span class="hljs-variable">@Location</span> NVARCHAR(<span class="hljs-number">100</span>), <span class="hljs-variable">@DisplayName</span> NVARCHAR(<span class="hljs-number">40</span>) <span class="hljs-keyword">AS</span>
<span class="hljs-keyword">BEGIN</span>
  <span class="hljs-keyword">DECLARE</span> <span class="hljs-variable">@Users</span> <span class="hljs-keyword">TABLE</span>
    (Id <span class="hljs-type">INT</span>,
    DisplayName NVARCHAR(<span class="hljs-number">40</span>),
    Location NVARCHAR(<span class="hljs-number">100</span>));

  <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-variable">@Users</span>(Id, DisplayName, Location)
    <span class="hljs-keyword">SELECT</span> Id, DisplayName, Location
    <span class="hljs-keyword">FROM</span> dbo.Users
    <span class="hljs-keyword">WHERE</span> Location <span class="hljs-operator">=</span> <span class="hljs-variable">@Location</span>;

  <span class="hljs-keyword">SELECT</span> TOP <span class="hljs-number">1000</span> <span class="hljs-operator">*</span>
    <span class="hljs-keyword">FROM</span> <span class="hljs-variable">@Users</span>
    <span class="hljs-keyword">WHERE</span> DisplayName <span class="hljs-operator">=</span> <span class="hljs-variable">@DisplayName</span>
    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> Location;
<span class="hljs-keyword">END</span>
GO

<span class="hljs-comment">/* Run this with actual plan on and note that the estimates are just 1 row: */</span>
<span class="hljs-keyword">EXEC</span> usp_GetUsers_TableVariable <span class="hljs-variable">@Location</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;India&#x27;</span>, <span class="hljs-variable">@DisplayName</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Abhishek&#x27;</span>

<span class="hljs-comment">/* Why 1 row?
  * SQL Server doesn&#x27;t know how many total rows are in the table variable, AND
  * SQL Server doesn&#x27;t know the data distribution either, like the breakdown per name
*/</span>

<span class="hljs-comment">/* Then while we measure recompiles in another window: */</span>
<span class="hljs-keyword">EXEC</span> dbo.sp_HumanEvents <span class="hljs-variable">@event</span>_type <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;recompilations&#x27;</span>, <span class="hljs-variable">@seconds</span>_sample <span class="hljs-operator">=</span> <span class="hljs-number">10</span>
GO

<span class="hljs-comment">/* Run these: */</span>
<span class="hljs-keyword">EXEC</span> usp_GetUsers_TableVariable <span class="hljs-variable">@Location</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;India&#x27;</span>, <span class="hljs-variable">@DisplayName</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Abhishek&#x27;</span>
<span class="hljs-keyword">EXEC</span> usp_GetUsers_TableVariable <span class="hljs-variable">@Location</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Russia&#x27;</span>, <span class="hljs-variable">@DisplayName</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Aleksey&#x27;</span>
<span class="hljs-keyword">EXEC</span> usp_GetUsers_TableVariable <span class="hljs-variable">@Location</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;India&#x27;</span>, <span class="hljs-variable">@DisplayName</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Abhishek&#x27;</span>
<span class="hljs-keyword">EXEC</span> usp_GetUsers_TableVariable <span class="hljs-variable">@Location</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Russia&#x27;</span>, <span class="hljs-variable">@DisplayName</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Aleksey&#x27;</span>
<span class="hljs-keyword">EXEC</span> usp_GetUsers_TableVariable <span class="hljs-variable">@Location</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;India&#x27;</span>, <span class="hljs-variable">@DisplayName</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Abhishek&#x27;</span>
<span class="hljs-keyword">EXEC</span> usp_GetUsers_TableVariable <span class="hljs-variable">@Location</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Russia&#x27;</span>, <span class="hljs-variable">@DisplayName</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Aleksey&#x27;</span>
GO


<span class="hljs-comment">/* So to recap table variables so far:

  * They don&#x27;t get statistics, so:
    * Bad  news: estimates are usually off, but
    * Good news: they don&#x27;t recompile as contents change

Something changed in SQL Server 2019, though: */</span>

<span class="hljs-keyword">ALTER</span> DATABASE <span class="hljs-keyword">CURRENT</span> <span class="hljs-keyword">SET</span> COMPATIBILITY_LEVEL <span class="hljs-operator">=</span> <span class="hljs-number">150</span>; <span class="hljs-comment">/* 2019 */</span>
GO

<span class="hljs-comment">/* Run this with actual plan on: */</span>
<span class="hljs-keyword">EXEC</span> usp_GetUsers_TableVariable <span class="hljs-variable">@Location</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;India&#x27;</span>, <span class="hljs-variable">@DisplayName</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Abhishek&#x27;</span>

<span class="hljs-comment">/* Before, we had an estimate of 1 row because:
  * SQL Server didn&#x27;t know how many total rows are in the table variable, AND
  * SQL Server didn&#x27;t know the data distribution either, like the breakdown per name

But now, hover your mouse over the table variable scan and look at Estimated Number of Rows to be Read.

In SQL Server 2019:
  * SQL Server DOES know how many rows are in it, but
  * Still doesn&#x27;t know the data distribution per name

In some ways, this is an improvement, but in other ways, it&#x27;s a drawback, because watch what happens if you run it for a 
DIFFERENT value:
*/</span>

<span class="hljs-keyword">EXEC</span> usp_GetUsers_TableVariable <span class="hljs-variable">@Location</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Russia&#x27;</span>, <span class="hljs-variable">@DisplayName</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;Aleksey&#x27;</span>

<span class="hljs-comment">/* Look at the table variable scan estimates:

* The estimated number of rows TO BE READ is the same
* The estimated number of rows TO BE FOUND is the same

This is NOT THE SAME THING that happens with temp tables. THIS IS DIFFERENT.

With temp table stats reuse:
  * You could inherit someone else&#x27;s table stats
  * You could inherit their estimates, too
  * Those estimates could change as the temp table&#x27;s contents changed as queries run

With table variables:
  * You WILL inherit the total number of rows in the object from the compiled plan
  * There are no column stats (data distribution) to inherit, so these are just consistently wrong
  * This has less to do with temp tables, and more like conventional parameter sniffing problems
*/</span>
</code></pre>
<ul>
<li>How Memory-Optimized Table Variables Reduce Contention</li>
</ul>
<p>In the last module, we finished up by showing how Microsoft used In-Memory OLTP (Hekaton) technology in SQL Server 2019 to let TempDB’s system tables work faster. That’s an easy way to reduce latch wait times, but it’s not the only way: you can directly adopt In-Memory OLTP yourself by changing your temp tables to use ’em.</p>
<pre><code class="language-sql"><span class="hljs-comment">/* If you&#x27;re on SQL Server 2019, check to make sure this returns a 0: */</span>
<span class="hljs-keyword">SELECT</span> SERVERPROPERTY(<span class="hljs-string">&#x27;IsTempDBMetadataMemoryOptimized&#x27;</span>);
GO

<span class="hljs-comment">/* If it returns a 1, let&#x27;s turn this feature off for now in order to demo SQL Server&#x27;s traditional problem in TempDB: */</span>
<span class="hljs-keyword">ALTER</span> SERVER CONFIGURATION <span class="hljs-keyword">SET</span> MEMORY_OPTIMIZED TEMPDB_METADATA<span class="hljs-operator">=</span>OFF;
<span class="hljs-comment">/* And you&#x27;ll then need to restart SQL Server. */</span>


<span class="hljs-comment">/* Before we start, review the number of files we&#x27;ve got in TempDB: */</span>
<span class="hljs-keyword">SELECT</span> type_desc, name, physical_name, 
  size <span class="hljs-operator">*</span> <span class="hljs-number">8.0</span> <span class="hljs-operator">/</span> <span class="hljs-number">1024</span> <span class="hljs-keyword">AS</span> size_mb
  <span class="hljs-keyword">FROM</span> tempdb.sys.database_files
  <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> type_desc <span class="hljs-keyword">DESC</span>;


USE StackOverflow2013;
GO
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">PROCEDURE</span> dbo.TempTable <span class="hljs-keyword">AS</span>
  <span class="hljs-keyword">SELECT</span> TOP <span class="hljs-number">1000</span> Id, AboutMe
  <span class="hljs-keyword">INTO</span> #t1
  <span class="hljs-keyword">FROM</span> dbo.Users <span class="hljs-keyword">WITH</span> (NOLOCK)
  OPTION (MAXDOP <span class="hljs-number">1</span>);
GO

<span class="hljs-comment">/* When you run just one, it&#x27;s quick: */</span>
<span class="hljs-keyword">SET</span> STATISTICS <span class="hljs-type">TIME</span>, IO <span class="hljs-keyword">ON</span>;
GO
<span class="hljs-keyword">EXEC</span> TempTable;

<span class="hljs-comment">/* But run that in SQLQueryStress on a lot of threads while we measure: */</span>
<span class="hljs-keyword">EXEC</span> sp_BlitzFirst <span class="hljs-variable">@ExpertMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, <span class="hljs-variable">@Seconds</span> <span class="hljs-operator">=</span> <span class="hljs-number">60</span>;
<span class="hljs-keyword">EXEC</span> sp_WhoIsActive;
GO


<span class="hljs-comment">/* What if we try table variables? */</span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">PROCEDURE</span> dbo.TableVariable <span class="hljs-keyword">AS</span>
<span class="hljs-keyword">BEGIN</span>
  <span class="hljs-keyword">DECLARE</span> <span class="hljs-variable">@TableVariable</span> <span class="hljs-keyword">TABLE</span> (Id <span class="hljs-type">INT</span>, AboutMe NVARCHAR(MAX));

  <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-variable">@TableVariable</span> (Id, AboutMe)
  <span class="hljs-keyword">SELECT</span> TOP <span class="hljs-number">1000</span> Id, AboutMe
  <span class="hljs-keyword">FROM</span> dbo.Users <span class="hljs-keyword">WITH</span> (NOLOCK)
  OPTION (MAXDOP <span class="hljs-number">1</span>);
<span class="hljs-keyword">END</span>
GO


<span class="hljs-comment">/* Try just one: */</span>
<span class="hljs-keyword">SET</span> STATISTICS <span class="hljs-type">TIME</span>, IO <span class="hljs-keyword">ON</span>;
GO
<span class="hljs-keyword">EXEC</span> TableVariable;

<span class="hljs-comment">/* Then run it in SQLQueryStress on a lot of threads. */</span>
<span class="hljs-keyword">EXEC</span> sp_BlitzFirst <span class="hljs-variable">@ExpertMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, <span class="hljs-variable">@Seconds</span> <span class="hljs-operator">=</span> <span class="hljs-number">60</span>;
<span class="hljs-keyword">EXEC</span> sp_WhoIsActive;
GO


<span class="hljs-comment">/* SQL Server 2019 brings a new system-level feature to help solve this: */</span>
<span class="hljs-keyword">ALTER</span> SERVER CONFIGURATION <span class="hljs-keyword">SET</span> MEMORY_OPTIMIZED TEMPDB_METADATA<span class="hljs-operator">=</span><span class="hljs-keyword">ON</span>;

<span class="hljs-comment">/* Restart the SQL Server instance for it to take effect, then check it: */</span>
<span class="hljs-keyword">SELECT</span> SERVERPROPERTY(<span class="hljs-string">&#x27;IsTempDBMetadataMemoryOptimized&#x27;</span>);
GO

<span class="hljs-comment">/* Then run both the TempTable and TableVariable load tests again while watching page latch waits. */</span>
<span class="hljs-keyword">EXEC</span> sp_BlitzFirst <span class="hljs-variable">@ExpertMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, <span class="hljs-variable">@Seconds</span> <span class="hljs-operator">=</span> <span class="hljs-number">60</span>;
<span class="hljs-keyword">EXEC</span> sp_WhoIsActive;
GO


<span class="hljs-comment">/* Turn this back off for the lab: */</span>
<span class="hljs-keyword">ALTER</span> SERVER CONFIGURATION <span class="hljs-keyword">SET</span> MEMORY_OPTIMIZED TEMPDB_METADATA<span class="hljs-operator">=</span>OFF;
<span class="hljs-comment">/* Restart the SQL Server instance for it to take effect, then check it: */</span>
<span class="hljs-keyword">SELECT</span> SERVERPROPERTY(<span class="hljs-string">&#x27;IsTempDBMetadataMemoryOptimized&#x27;</span>);
GO

<span class="hljs-comment">/* During the break, check your production servers to see how many files they have: */</span>
<span class="hljs-keyword">SELECT</span> type_desc, name, physical_name, 
  size <span class="hljs-operator">*</span> <span class="hljs-number">8.0</span> <span class="hljs-operator">/</span> <span class="hljs-number">1024</span> <span class="hljs-keyword">AS</span> size_mb
  <span class="hljs-keyword">FROM</span> tempdb.sys.database_files
  <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> type_desc <span class="hljs-keyword">DESC</span>;
GO
<span class="hljs-comment">/* And look for PAGELATCH waits amongst your top 10, indicating that you may need more files (or a code change): */</span>
sp_BlitzFirst <span class="hljs-variable">@OutputType</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Top10&#x27;</span>

<span class="hljs-comment">/* Not PAGEIOLATCH% or LATCH% - we&#x27;re specifically looking for PAGELATCH%. */</span>
</code></pre>
<ul>
<li>How Execution Plans Use TempDB</li>
</ul>
<p>When you see a yellow bang warnings on sort, hash match, or adaptive join operators in an execution plan, that’s a sign that TempDB was invited to the party. When SQL Server runs out of memory, the data spills over into TempDB. Let’s see how it happens, and what we can do about it.</p>
<pre><code class="language-sql">USE StackOverflow2013;
GO

<span class="hljs-comment">/* Use the newest compat level your server supports, but not SQL Server 2019 yet. 130 = 2016, 140 = 2017. */</span>
<span class="hljs-keyword">ALTER</span> DATABASE <span class="hljs-keyword">CURRENT</span> <span class="hljs-keyword">SET</span> COMPATIBILITY_LEVEL <span class="hljs-operator">=</span> <span class="hljs-number">140</span>;
GO
DropIndexes;
GO
<span class="hljs-keyword">CREATE</span> INDEX IX_OwnerUserId <span class="hljs-keyword">ON</span> dbo.Posts(OwnerUserId) INCLUDE (Score, Title);
GO

<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">ALTER</span> PROC dbo.usp_UsersInTopLocation <span class="hljs-keyword">AS</span>
<span class="hljs-keyword">BEGIN</span>
  <span class="hljs-keyword">WITH</span> TopLocation <span class="hljs-keyword">AS</span> (
    <span class="hljs-keyword">SELECT</span> TOP <span class="hljs-number">1</span> 
      Location
    <span class="hljs-keyword">FROM</span> dbo.Users
    <span class="hljs-keyword">WHERE</span> Location <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-string">&#x27;&#x27;</span>
    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> Location
    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">DESC</span>
  )
  <span class="hljs-keyword">SELECT</span>	u.<span class="hljs-operator">*</span>
  <span class="hljs-keyword">FROM</span>	TopLocation
  <span class="hljs-keyword">JOIN</span>	dbo.Users u 
  <span class="hljs-keyword">ON</span>		TopLocation.Location <span class="hljs-operator">=</span> u.Location
  <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> DisplayName;
<span class="hljs-keyword">END</span>
GO

<span class="hljs-comment">/* Run this with actual plans on: */</span>
DBCC FREEPROCCACHE;

<span class="hljs-keyword">EXEC</span> usp_UsersInTopLocation
GO

<span class="hljs-comment">/* Things to discuss:
  1. Estimates vs actuals through query
    1.1 Memory grant: ____ KB
    1.2 Memory used : ____ KB
    1.3 How many operators spilled

  Run it again. Do things improve? 

  To find queries having the problem, turn off actual plans and run: */</span>

sp_BlitzCache <span class="hljs-variable">@SortOrder</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;spills&#x27;</span>

<span class="hljs-comment">/* Things to <span class="hljs-doctag">note:</span>
  1. Memory grant: granted, used
  2. Spills: min, max, total, avg

  In this case, adding more memory won&#x27;t help: the query just doesn&#x27;t want enough memory.

  To learn a few ways to fix it with index &amp; query tuning, watch my Fundamentals of Query Tuning:
  https://BrentOzar.com/go/queryfund

  SQL Server 2019 has a way to fix it though:
*/</span>
<span class="hljs-keyword">ALTER</span> DATABASE <span class="hljs-keyword">CURRENT</span> <span class="hljs-keyword">SET</span> COMPATIBILITY_LEVEL <span class="hljs-operator">=</span> <span class="hljs-number">150</span>;

<span class="hljs-keyword">ALTER</span> DATABASE SCOPED CONFIGURATION <span class="hljs-keyword">SET</span> LAST_QUERY_PLAN_STATS <span class="hljs-operator">=</span> <span class="hljs-keyword">ON</span>;
GO

DBCC FREEPROCCACHE;

<span class="hljs-keyword">EXEC</span> usp_UsersInTopLocation
GO

<span class="hljs-comment">/* Things to discuss:

  1. Estimates vs actuals through query
    1.1 Memory grant: ____ KB (is this higher?)
    1.2 Memory used: ____ KB
    1.3 How many operators spilled

  Now we have a different problem: we got granted too much memory!

  Try running it a few more times to see if it gets better/worse: */</span>

<span class="hljs-keyword">EXEC</span> usp_UsersInTopLocation
GO <span class="hljs-number">10</span>

<span class="hljs-comment">/* Turn off actual plans: */</span>
sp_BlitzCache;
GO

<span class="hljs-comment">/* Look at these columns:
  * Minimum Memory Grant KB
  * Maximum Memory Grant KB

  * Minimum Used Grant KB
  * Maximum Used Grant KB

  * Spills - min, max, total, avg

  That&#x27;s a query that behaves the same way every time because it doesn&#x27;t have parameters. If we use a more complex proc:
*/</span>

<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">ALTER</span> PROC dbo.usp_UsersByReputation <span class="hljs-variable">@Reputation</span> <span class="hljs-type">INT</span> <span class="hljs-keyword">AS</span>
    <span class="hljs-keyword">SELECT</span> TOP <span class="hljs-number">100000</span> u.Id, p.Title, p.Score
    <span class="hljs-keyword">FROM</span> dbo.Users u
    <span class="hljs-keyword">JOIN</span> dbo.Posts p 
  <span class="hljs-keyword">ON</span>   p.OwnerUserId <span class="hljs-operator">=</span> u.Id
    <span class="hljs-keyword">WHERE</span> u.Reputation <span class="hljs-operator">=</span> <span class="hljs-variable">@Reputation</span>
    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> p.Score <span class="hljs-keyword">DESC</span>;
GO

<span class="hljs-comment">/* And run it: */</span>
DBCC FREEPROCCACHE;

<span class="hljs-comment">/* Turn on actual plans: */</span> 
<span class="hljs-keyword">EXEC</span> usp_UsersByReputation <span class="hljs-variable">@Reputation</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;
GO


<span class="hljs-comment">/* Check out that adaptive join:
  * Adaptive threshold in tooltip
  * Over threshold: do an index scan
  * Under: do a seek

  * Also, note that nothing spills.

Try another reputation: */</span>
<span class="hljs-keyword">EXEC</span> usp_UsersByReputation <span class="hljs-variable">@Reputation</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;
GO

<span class="hljs-comment">/* It chooses the seek, but...we have a yellow bang. SQL Server is about to adjust the memory grant downwards because we left 
too much unused. Try it again: */</span>
<span class="hljs-keyword">EXEC</span> usp_UsersByReputation <span class="hljs-variable">@Reputation</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;

<span class="hljs-comment">/* And the memory grant goes down. But now try the big one again: */</span>
<span class="hljs-keyword">EXEC</span> usp_UsersByReputation <span class="hljs-variable">@Reputation</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;
GO


<span class="hljs-comment">/* Turn OFF actual plans, and: */</span>
sp_BlitzCache

<span class="hljs-comment">/* Look at the:
  * Query plan - last actual plan enabled
  * Min/max memory grants
  * Spills (!!!) */</span>


<span class="hljs-comment">/* Takeaways from this:

* This TempDB consumer is particularly hard to predict: it&#x27;s different on a query-by-query basis, and changes with SQL Server 
  versions.

* Microsoft&#x27;s trying to make it better with adaptive memory grants, but right now, it&#x27;s worse instead of better.

* To look for queries causing spills, run: sp_BlitzCache @SortOrder = &#x27;spills&#x27;

* In their plans, look for:
  * Sorts
  * Hash matches
  * Adaptive joins

During the break, check your own production server&#x27;s plan cache to see which queries have been spilling the most to disk:
*/</span>

sp_BlitzCache <span class="hljs-variable">@SortOrder</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;spills&#x27;</span>;
GO

<span class="hljs-comment">/* And scroll across to the Total Spills column. */</span>
</code></pre>
<ul>
<li>Other TempDB Consumers: Cursors, Index Builds, AG Statistics</li>
</ul>
<p>I often joke that TempDB is like SQL Server’s public toilet: there’s all kinds of crazy stuff happening inside there. Seems like whenever Microsoft needs a holding place for something, they resort to TempDB. That’s not necessarily bad – we gotta put it somewhere – but being aware of these extra uses will come in handy
if your workload relies heavily on one of these unusual consumers.</p>
<pre><code class="language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;ALTER DATABASE tempdb MODIFY FILE (NAME = [&#x27;</span> <span class="hljs-operator">+</span> f.name <span class="hljs-operator">+</span> <span class="hljs-string">&#x27;],&#x27;</span>
  <span class="hljs-operator">+</span> <span class="hljs-string">&#x27; FILENAME = &#x27;&#x27;Z:\MSSQL\DATA\&#x27;</span> <span class="hljs-operator">+</span> f.name
  <span class="hljs-operator">+</span> <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> f.type <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;.ldf&#x27;</span> <span class="hljs-keyword">ELSE</span> <span class="hljs-string">&#x27;.mdf&#x27;</span> <span class="hljs-keyword">END</span>
  <span class="hljs-operator">+</span> <span class="hljs-string">&#x27;&#x27;&#x27;);&#x27;</span>
<span class="hljs-keyword">FROM</span> sys.master_files f
<span class="hljs-keyword">WHERE</span> f.database_id <span class="hljs-operator">=</span> DB_ID(N<span class="hljs-string">&#x27;tempdb&#x27;</span>);
</code></pre>
<ul>
<li>How bit the TempDB should be?
It’s impossible to guess this stuff.
If you’re building a new server, you just can’t know.
My guideline: 25% of the total data size
on the entire server.
Yes, even on 10TB data warehouses:
after all, we do big data loads &amp; reloads.</li>
</ul>
<p>There are exceptions.
Client scenario, simplified:
• The server has 10TB of data
• It’s 10 databases, each 1TB
• Each 1TB database has a single 800GB table (that’s ten 800GB tables in total)
• They rebuild indexes in parallel, with sort_in_tempdb = on.  They needed at least 8TB TempDB space.</p>
<p>Another example
• 20TB database
• Crazy fast SAN, no point of sort_in_tempdb
• In a sync Availability Group (we couldn’t rebuild indexes)
• No transactions, triggers,  version store (all nolock)
• 100GB TempDB would be fine</p>
<ul>
<li>Where do we put it?
Solid state storage. In this day and age, nothing latency-sensitive should be on magnetic hard drives.
If you’re on a bare metal server...
If you’re on dedicated hardware (not a VM), I strongly recommend using local SSD for TempDB.
It’s cheap: under $500/TB, much cheaper than SAN.
It’s fast: sub-millisecond latency.
It keeps your storage network free from TempDB traffic, letting it focus on valuable traffic to real databases.
It doesn’t need to persist: it’s okay if the contents don’t fail over when the server restarts.</li>
</ul>
<p>If you’re in a VM in the cloud...
If you’re in a cloud VM like AWS EC2 or Azure VMs, use ephemeral storage.
That’s the cloud term for local SSD.
It does disappear when the VM dies, but that’s just like local SSD on a bare metal machine.
It’s WAY faster than shared storage in the cloud.</p>
<p>If you’re in a conventional VM...
If you’re hosting your VMs in VMware or Hyper-V, you’ll probably have to put TempDB on the SAN.
Your VM admins won’t want to use local SSD.
If they use local SSD, they won’t be able to fail a VM around to different servers.
This is just the price you pay for virtualization’s higher availability.
If you’re in a VM, continued Should TempDB be on its own dedicated volume?(Remember: this point is irrelevant for bare metal or cloud VMs because in those cases, you’d be using a pair of mirrored local SSDs anyway.)
Can your sysadmins disable SAN replication on the TempDB volume? If so, use a separate volume. Can they set different caching settings on the TempDB volume? If so, check with your storage vendor’s best practices.</p>
<p>If it’s on a dedicated volume...
And if that volume has pretty limited space, I’ve used an emergency vent valve file.
Create a 1MB file on a much larger volume Enable autogrowth in a big increment Set up alerts for when that file grows
(and it’s a real emergency) Proportional fill means we won’t use it a lot</p>
<ul>
<li>How many data files do we need?
Normal databases have 1 data file.
And this file will have one of each of those special PFS and SGAM pages. (It gets more pages as its size grows.)
This is fine for regular databases, but...tempdb data file TempDB is different.
New objects created Objects dropped System databases Almost never Almost never User databases Every now and then Every now and then
TempDB CONSTANTLY CONSTANTLY</li>
</ul>
<p>This causes a problem.
SQL Server was never really designed for constant creation/dropping of objects.
To create or drop an object, SQL Server has to write to special system pages.
•PFS: Page Free Space pages
•SGAM: Shared Global Allocation Map pages</p>
<p>Latches protect these pages in memory.
Think of this as a lightweight lock.
This isn’t a disk storage problem.
It’s about contention for a system page.
These pages are stored on disk.
But we’re not waiting on disk to get ‘em.
We have these contention problems even when the data is stored in RAM. The fix is a little odd...
How to configure TempDB
Create 4-8 equally sized data files.
The exact number is less important than just “more.”
If you’re using local (ephemeral) storage:
• Take the total available space
• Divide that by 5
• Create 4 data files with that size
• Create 1 log file with that size</p>
<ul>
<li>
<p>How many log files do we need?
Just 1. Log file access is sequential.
SQL Server starts at the beginning of the log, Logs transactions, And when it gets to the end of the log file, If space at the beginning is available for reuse, it’ll loop back and reuse that, Otherwise it grows the log file out.</p>
</li>
<li>
<p>Should we enable autogrowth?
If you’re on bare metal or cloud...
Then you used a dedicated local SSD volume for TempDB anyway.
It’s dedicated to TempDB.
Just grow the files out to fill the space.
You’re done: you’ll never have to worry about monitoring for growths. Growing is done.
You just have to worry about it filling up.
If you’re on a VM, sharing space...
If you decided to use a single volume for both user databases &amp; log files, plus TempDB, it gets harder.
You’ll probably want to:
• Configure the TempDB data files to total up to 25% of the size of the server’s data, but
• Still leave autogrowth enabled in case someone does something terrible – try not to go down.</p>
</li>
<li>
<p>What if we run out of space?
You will. It’s a matter of time.
Someone’s gonna do something bad.
You just need to prepare by:
• Monitoring what percentage of TempDB has been used, and
• Send alerts when it’s high enough that you need to investigate, and
• Leave yourself time to take action</p>
</li>
<li>
<p>Should we enable trace flags?
For SQL Server 2014 &amp; prior, yes:
Trace flag 1117: grows all data files in a filegroup equally (but also applies to user databases).
Trace flag 1118: doesn’t use mixed extents in TempDB, alleviates some of the pressure.</p>
</li>
</ul>
<p>To set up trace flags to run at startup, use SQL Server Configuration Manager: <a href="https://docs.microsoft.com/en-">https://docs.microsoft.com/en-</a>
us/sql/database-engine/configure-windows/scm-services-configure-server-startup-options</p>
<p>But 2016 &amp; subsequent versions don’t need these</p>
<p>SQL Server 2016 &amp; later
1117: replaced by AUTOGROW_ALL_FILES option of ALTER DATABASE. (Default = on for TempDB, but not user dbs.)
1118: replaced by MIXED_PAGE_ALLOCATION ON argument for ALTER DATABASE SET. (Default = on for all system databases, but off
for user dbs.)</p>
<ul>
<li>Should we change an existing server?
One extreme: tiny TempDB Someone’s been shrinking files TempDB’s size is much smaller than what I’d expect, like total DBs are 1TB, and TempDB 10GB (1%) They were shrinking because we didn’t have enough available drive space</li>
</ul>
<p>Solution: get more drive space before you change anything</p>
<p>Other extreme: giant single file No one was managing TempDB We have just one data file, and it’s big
Solution:
• Note its data file size
• Shrink it back down to zero
• Grow it back out to ¼ of the prior size
• Add 3 more data files, all that same size Anything else: leave it.</p>
<p>Don’t stress out over:
• The exact number of files
• The exact size of data &amp; log files</p>
<p>As long as:
• Data files are all equally sized
• Monitoring doesn’t indicate a TempDB bottleneck</p>
<ul>
<li>Monitoring tempdb
What we need to monitor
Does it have enough capacity?
If not, what’s using the space?
Are the pages in memory fast enough?
If not, do we need more files, and why?
Are the pages on disk fast enough?
I demoed it with scripts, but the tool you use to save the data may vary.</li>
</ul>
<p>How to use them
Review the list of TempDB things to track Review the tool’s thresholds Configure email alerting in a way that gives you time to react,
but minimizes false alarms Don’t set up rules to folder-ize emails</p>
<ul>
<li>Where to store data temporarily
This should be an image</li>
</ul>

            <script async src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
            
        </body>
        </html>